"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/utils/helpers.jsx":
/*!*******************************!*\
  !*** ./src/utils/helpers.jsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decideSearchType: function() { return /* binding */ decideSearchType; }\n/* harmony export */ });\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! openai */ \"./node_modules/openai/index.mjs\");\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env.js */ \"./src/env.js\");\n\n\nconst openai = new openai__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n    apiKey: _env_js__WEBPACK_IMPORTED_MODULE_0__.env.NEXT_PUBLIC_OPENAI_API_KEY,\n    dangerouslyAllowBrowser: true\n}); // TODO: edit later\n// Let's generalize the prompt and call the search types (1) and (2) in case the LLM is sensitive to the names. We can replace them with different names programmatically to see what works best.\nconst SEARCH_TYPE_EXPLANATION = \"- (1) search is usually preferred when the query is a broad topic or semantically complex because it lets us retrieve high quality, semantically relevant data. (1) search is especially suitable when a topic is well-known and popularly discussed on the Internet, allowing the machine learning model to retrieve contents which are more likely recommended by real humans.  \\n- (2) search is useful when the topic is specific, local or obscure. If the query is a specific person's name, and identifier, or acronym, such that relevant results will contain the query itself, (2) search may do well. And if the machine learning model doesn't know about the topic, but relevant documents can be found by directly matching the search query, (2) search may be necessary.\\n\";\nasync function getLLMResponse(param) {\n    let { system = \"You are a helpful assistant.\", user = \"\", temperature = 1, model = \"gpt-3.5-turbo\" } = param;\n    const completion = await openai.chat.completions.create({\n        model,\n        temperature,\n        messages: [\n            {\n                \"role\": \"system\",\n                \"content\": system\n            },\n            {\n                \"role\": \"user\",\n                \"content\": user\n            }\n        ]\n    });\n    return completion.choices[0].message.content;\n}\n// LLM chooses between search types and returns best type\nasync function decideSearchType(topic) {\n    let choiceNames = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [\n        \"neural\",\n        \"keyword\"\n    ];\n    let userMessage = 'Decide whether to use (1) or (2) search for the provided research topic. Output your choice in a single word: either \"(1)\" or \"(2)\". Here is a guide that will help you choose:\\n';\n    userMessage += SEARCH_TYPE_EXPLANATION;\n    userMessage += \"Topic: \".concat(topic, \"\\n\");\n    userMessage += \"Search type: \";\n    userMessage = userMessage.replaceAll(\"(1)\", choiceNames[0]).replaceAll(\"(2)\", choiceNames[1]);\n    const response = getLLMResponse({\n        system: \"You will be asked to make a choice between two options. Answer with your choice in a single word.\",\n        user: userMessage,\n        temperature: 0\n    });\n    console.log(\"r\", response);\n    const useKeyword = response.then().trim().toLowerCase().startsWith(choiceNames[1].toLowerCase());\n    return useKeyword ? \"keyword\" : \"neural\";\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvaGVscGVycy5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRCO0FBQ0k7QUFFaEMsTUFBTUUsU0FBUyxJQUFJRiw4Q0FBTUEsQ0FBQztJQUFFRyxRQUFRRix3Q0FBR0EsQ0FBQ0csMEJBQTBCO0lBQUVDLHlCQUF5QjtBQUFJLElBQUssbUJBQW1CO0FBRXpILGlNQUFpTTtBQUNqTSxNQUFNQywwQkFBMkI7QUFJakMsZUFBZUMsZUFBZSxLQUE4RjtRQUE5RixFQUFDQyxTQUFTLDhCQUE4QixFQUFFQyxPQUFPLEVBQUUsRUFBRUMsY0FBYyxDQUFDLEVBQUVDLFFBQVEsZUFBZSxFQUFDLEdBQTlGO0lBQzFCLE1BQU1DLGFBQWEsTUFBTVYsT0FBT1csSUFBSSxDQUFDQyxXQUFXLENBQUNDLE1BQU0sQ0FBQztRQUNwREo7UUFDQUQ7UUFDQU0sVUFBVTtZQUNOO2dCQUFDLFFBQVE7Z0JBQVUsV0FBV1I7WUFBTTtZQUNwQztnQkFBQyxRQUFRO2dCQUFRLFdBQVdDO1lBQUk7U0FDbkM7SUFDTDtJQUNBLE9BQU9HLFdBQVdLLE9BQU8sQ0FBQyxFQUFFLENBQUNDLE9BQU8sQ0FBQ0MsT0FBTztBQUNoRDtBQUVBLHlEQUF5RDtBQUNsRCxlQUFlQyxpQkFBaUJDLEtBQUs7UUFBRUMsY0FBQUEsaUVBQWM7UUFBQztRQUFVO0tBQVU7SUFDN0UsSUFBSUMsY0FBYztJQUNsQkEsZUFBZWpCO0lBQ2ZpQixlQUFlLFVBQWdCLE9BQU5GLE9BQU07SUFDL0JFLGVBQWdCO0lBQ2hCQSxjQUFjQSxZQUFZQyxVQUFVLENBQUMsT0FBT0YsV0FBVyxDQUFDLEVBQUUsRUFBRUUsVUFBVSxDQUFDLE9BQU9GLFdBQVcsQ0FBQyxFQUFFO0lBRTVGLE1BQU1HLFdBQVdsQixlQUFlO1FBQzVCQyxRQUFRO1FBQ1JDLE1BQU1jO1FBQ05iLGFBQWE7SUFDakI7SUFDQWdCLFFBQVFDLEdBQUcsQ0FBQyxLQUFLRjtJQUNqQixNQUFNRyxhQUFhSCxTQUFTSSxJQUFJLEdBQUdDLElBQUksR0FBR0MsV0FBVyxHQUFHQyxVQUFVLENBQUNWLFdBQVcsQ0FBQyxFQUFFLENBQUNTLFdBQVc7SUFDN0YsT0FBT0gsYUFBYSxZQUFZO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9oZWxwZXJzLmpzeD85YTA0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBPcGVuQUkgZnJvbSAnb3BlbmFpJztcbmltcG9ydCB7IGVudiB9IGZyb20gXCIuLi9lbnYuanNcIjtcblxuY29uc3Qgb3BlbmFpID0gbmV3IE9wZW5BSSh7IGFwaUtleTogZW52Lk5FWFRfUFVCTElDX09QRU5BSV9BUElfS0VZLCBkYW5nZXJvdXNseUFsbG93QnJvd3NlcjogdHJ1ZX0pOyAgLy8gVE9ETzogZWRpdCBsYXRlclxuXG4vLyBMZXQncyBnZW5lcmFsaXplIHRoZSBwcm9tcHQgYW5kIGNhbGwgdGhlIHNlYXJjaCB0eXBlcyAoMSkgYW5kICgyKSBpbiBjYXNlIHRoZSBMTE0gaXMgc2Vuc2l0aXZlIHRvIHRoZSBuYW1lcy4gV2UgY2FuIHJlcGxhY2UgdGhlbSB3aXRoIGRpZmZlcmVudCBuYW1lcyBwcm9ncmFtbWF0aWNhbGx5IHRvIHNlZSB3aGF0IHdvcmtzIGJlc3QuXG5jb25zdCBTRUFSQ0hfVFlQRV9FWFBMQU5BVElPTiA9IGAtICgxKSBzZWFyY2ggaXMgdXN1YWxseSBwcmVmZXJyZWQgd2hlbiB0aGUgcXVlcnkgaXMgYSBicm9hZCB0b3BpYyBvciBzZW1hbnRpY2FsbHkgY29tcGxleCBiZWNhdXNlIGl0IGxldHMgdXMgcmV0cmlldmUgaGlnaCBxdWFsaXR5LCBzZW1hbnRpY2FsbHkgcmVsZXZhbnQgZGF0YS4gKDEpIHNlYXJjaCBpcyBlc3BlY2lhbGx5IHN1aXRhYmxlIHdoZW4gYSB0b3BpYyBpcyB3ZWxsLWtub3duIGFuZCBwb3B1bGFybHkgZGlzY3Vzc2VkIG9uIHRoZSBJbnRlcm5ldCwgYWxsb3dpbmcgdGhlIG1hY2hpbmUgbGVhcm5pbmcgbW9kZWwgdG8gcmV0cmlldmUgY29udGVudHMgd2hpY2ggYXJlIG1vcmUgbGlrZWx5IHJlY29tbWVuZGVkIGJ5IHJlYWwgaHVtYW5zLiAgXG4tICgyKSBzZWFyY2ggaXMgdXNlZnVsIHdoZW4gdGhlIHRvcGljIGlzIHNwZWNpZmljLCBsb2NhbCBvciBvYnNjdXJlLiBJZiB0aGUgcXVlcnkgaXMgYSBzcGVjaWZpYyBwZXJzb24ncyBuYW1lLCBhbmQgaWRlbnRpZmllciwgb3IgYWNyb255bSwgc3VjaCB0aGF0IHJlbGV2YW50IHJlc3VsdHMgd2lsbCBjb250YWluIHRoZSBxdWVyeSBpdHNlbGYsICgyKSBzZWFyY2ggbWF5IGRvIHdlbGwuIEFuZCBpZiB0aGUgbWFjaGluZSBsZWFybmluZyBtb2RlbCBkb2Vzbid0IGtub3cgYWJvdXQgdGhlIHRvcGljLCBidXQgcmVsZXZhbnQgZG9jdW1lbnRzIGNhbiBiZSBmb3VuZCBieSBkaXJlY3RseSBtYXRjaGluZyB0aGUgc2VhcmNoIHF1ZXJ5LCAoMikgc2VhcmNoIG1heSBiZSBuZWNlc3NhcnkuXG5gO1xuXG5hc3luYyBmdW5jdGlvbiBnZXRMTE1SZXNwb25zZSh7c3lzdGVtID0gJ1lvdSBhcmUgYSBoZWxwZnVsIGFzc2lzdGFudC4nLCB1c2VyID0gJycsIHRlbXBlcmF0dXJlID0gMSwgbW9kZWwgPSAnZ3B0LTMuNS10dXJibyd9KXtcbiAgICBjb25zdCBjb21wbGV0aW9uID0gYXdhaXQgb3BlbmFpLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICAgICAgbW9kZWwsXG4gICAgICAgIHRlbXBlcmF0dXJlLFxuICAgICAgICBtZXNzYWdlczogW1xuICAgICAgICAgICAgeydyb2xlJzogJ3N5c3RlbScsICdjb250ZW50Jzogc3lzdGVtfSxcbiAgICAgICAgICAgIHsncm9sZSc6ICd1c2VyJywgJ2NvbnRlbnQnOiB1c2VyfSxcbiAgICAgICAgXVxuICAgIH0pO1xuICAgIHJldHVybiBjb21wbGV0aW9uLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50O1xufVxuXG4vLyBMTE0gY2hvb3NlcyBiZXR3ZWVuIHNlYXJjaCB0eXBlcyBhbmQgcmV0dXJucyBiZXN0IHR5cGVcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNpZGVTZWFyY2hUeXBlKHRvcGljLCBjaG9pY2VOYW1lcyA9IFsnbmV1cmFsJywgJ2tleXdvcmQnXSl7XG4gICAgbGV0IHVzZXJNZXNzYWdlID0gJ0RlY2lkZSB3aGV0aGVyIHRvIHVzZSAoMSkgb3IgKDIpIHNlYXJjaCBmb3IgdGhlIHByb3ZpZGVkIHJlc2VhcmNoIHRvcGljLiBPdXRwdXQgeW91ciBjaG9pY2UgaW4gYSBzaW5nbGUgd29yZDogZWl0aGVyIFwiKDEpXCIgb3IgXCIoMilcIi4gSGVyZSBpcyBhIGd1aWRlIHRoYXQgd2lsbCBoZWxwIHlvdSBjaG9vc2U6XFxuJztcbiAgICB1c2VyTWVzc2FnZSArPSBTRUFSQ0hfVFlQRV9FWFBMQU5BVElPTjtcbiAgICB1c2VyTWVzc2FnZSArPSBgVG9waWM6ICR7dG9waWN9XFxuYDtcbiAgICB1c2VyTWVzc2FnZSArPSBgU2VhcmNoIHR5cGU6IGA7XG4gICAgdXNlck1lc3NhZ2UgPSB1c2VyTWVzc2FnZS5yZXBsYWNlQWxsKCcoMSknLCBjaG9pY2VOYW1lc1swXSkucmVwbGFjZUFsbCgnKDIpJywgY2hvaWNlTmFtZXNbMV0pO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBnZXRMTE1SZXNwb25zZSh7XG4gICAgICAgIHN5c3RlbTogJ1lvdSB3aWxsIGJlIGFza2VkIHRvIG1ha2UgYSBjaG9pY2UgYmV0d2VlbiB0d28gb3B0aW9ucy4gQW5zd2VyIHdpdGggeW91ciBjaG9pY2UgaW4gYSBzaW5nbGUgd29yZC4nLFxuICAgICAgICB1c2VyOiB1c2VyTWVzc2FnZSxcbiAgICAgICAgdGVtcGVyYXR1cmU6IDBcbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZygncicsIHJlc3BvbnNlKVxuICAgIGNvbnN0IHVzZUtleXdvcmQgPSByZXNwb25zZS50aGVuKCkudHJpbSgpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChjaG9pY2VOYW1lc1sxXS50b0xvd2VyQ2FzZSgpKTtcbiAgICByZXR1cm4gdXNlS2V5d29yZCA/ICdrZXl3b3JkJyA6ICduZXVyYWwnO1xufVxuIl0sIm5hbWVzIjpbIk9wZW5BSSIsImVudiIsIm9wZW5haSIsImFwaUtleSIsIk5FWFRfUFVCTElDX09QRU5BSV9BUElfS0VZIiwiZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXIiLCJTRUFSQ0hfVFlQRV9FWFBMQU5BVElPTiIsImdldExMTVJlc3BvbnNlIiwic3lzdGVtIiwidXNlciIsInRlbXBlcmF0dXJlIiwibW9kZWwiLCJjb21wbGV0aW9uIiwiY2hhdCIsImNvbXBsZXRpb25zIiwiY3JlYXRlIiwibWVzc2FnZXMiLCJjaG9pY2VzIiwibWVzc2FnZSIsImNvbnRlbnQiLCJkZWNpZGVTZWFyY2hUeXBlIiwidG9waWMiLCJjaG9pY2VOYW1lcyIsInVzZXJNZXNzYWdlIiwicmVwbGFjZUFsbCIsInJlc3BvbnNlIiwiY29uc29sZSIsImxvZyIsInVzZUtleXdvcmQiLCJ0aGVuIiwidHJpbSIsInRvTG93ZXJDYXNlIiwic3RhcnRzV2l0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utils/helpers.jsx\n"));

/***/ })

});